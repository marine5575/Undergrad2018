// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.10/04       [395780]
Creator        : marine5575
Date           : Wed Oct  9 17:29:28 2019
Host           : Linux htop.hanyang.ac.kr 2.6.32-696.el6.centos.plus.x86_64 #1 SMP Mon Apr 3 14:56:08 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /home/marine5575/work/Undergrad2018/mva
Training events: 65134
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "50" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "20" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "Grad" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
Shrinkage: "5.000000e-01" [Learning rate for GradBoost algorithm]
SeparationType: "giniindex" [Separation criterion for node splitting]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "3" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "pray" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 11
lepton1_pt                    lepton1_pt                    lepton1_pt                    lepton1_pt                                                      'F'    [30.0022735596,875.963500977]
met_pt                        met_pt                        met_pt                        met_pt                                                          'F'    [0.174064293504,815.994018555]
tau1_pt                       tau1_pt                       tau1_pt                       tau1_pt                                                         'F'    [30.0001525879,1040.04150391]
jet_ht                        jet_ht                        jet_ht                        jet_ht                                                          'F'    [95.0174484253,3019.39990234]
jetlepmet_ht                  jetlepmet_ht                  jetlepmet_ht                  jetlepmet_ht                                                    'F'    [155.10949707,3288.48583984]
lep1met_pt                    lep1met_pt                    lep1met_pt                    lep1met_pt                                                      'F'    [0.211814135313,879.103881836]
lep1tau1_pt                   lep1tau1_pt                   lep1tau1_pt                   lep1tau1_pt                                                     'F'    [0.17061945796,1256.81884766]
tau1_lep1_dr                  tau1_lep1_dr                  tau1_lep1_dr                  tau1_lep1_dr                                                    'F'    [0.390903234482,5.5550994873]
lep1_met_dphi                 lep1_met_dphi                 lep1_met_dphi                 lep1_met_dphi                                                   'F'    [-3.14144611359,3.14149641991]
tau1_met_dphi                 tau1_met_dphi                 tau1_met_dphi                 tau1_met_dphi                                                   'F'    [-3.14148163795,3.14157342911]
tau1lep1_met_dphi             tau1lep1_met_dphi             tau1lep1_met_dphi             tau1lep1_met_dphi                                               'F'    [-3.14146351814,3.14153146744]
NSpec 2
njet                          njet                          njet                          njet                                                            'F'    [3,12]
nbjet                         nbjet                         nbjet                         nbjet                                                           'F'    [0,6]


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 11 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "lepton1_pt", "met_pt", "tau1_pt", "jet_ht", "jetlepmet_ht", "lep1met_pt", "lep1tau1_pt", "tau1_lep1_dr", "lep1_met_dphi", "tau1_met_dphi", "tau1lep1_met_dphi" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';
      fType[10] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[11];
   double fVmax[11];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[11];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += current->GetResponse();
   }
   return 2.0/(1.0+exp(-2.0*myMVA))-1.0;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.817326,0.274263) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.709085,0.187429) , 
7, 1.78104, 1, 0, 0.755293,0.255293) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.679263,0.162358) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.527781,0.026557) , 
7, 2.11993, 1, 0, 0.608304,0.108304) , 
1, 24.2216, 1, 0, 0.68791,0.18791) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.552085,0.0493512) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.389587,-0.111176) , 
1, 76.0267, 1, 0, 0.484616,-0.0153836) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.374593,-0.127008) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.173247,-0.358969) , 
5, 126.224, 1, 0, 0.303632,-0.196368) , 
7, 1.61451, 1, 0, 0.358723,-0.141277) , 
1, 39.0226, 1, 0, 0.5,-3.02844e-15)    );
  // itree = 1
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.631167,0.0492984) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.765284,0.166543) , 
2, 38.7452, 1, 0, 0.727725,0.146161) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.714745,0.106557) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.441541,-0.109382) , 
7, 2.24094, 1, 0, 0.618348,0.0351881) , 
4, 433.109, 1, 0, 0.68791,0.105765) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.342716,-0.109396) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.477523,0.021118) , 
9, -0.747894, 1, 0, 0.432741,-0.0203297) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.413663,-0.0312877) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.224342,-0.179039) , 
7, 1.37658, 1, 0, 0.265279,-0.12821) , 
1, 76.0224, 1, 0, 0.358723,-0.0680129) , 
1, 39.0226, 1, 0, 0.5,0.00656738)    );
  // itree = 2
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.645673,0.0362171) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.331786,-0.097089) , 
1, 35.5646, 1, 0, 0.468502,-0.034135) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.666297,0.116668) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.575571,0.0329247) , 
9, 1.04722, 1, 0, 0.639329,0.0922609) , 
2, 39.3511, 1, 0, 0.584021,0.0513387) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.649381,0.064447) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.344822,-0.0542295) , 
1, 77.8712, 1, 0, 0.555944,0.0304969) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.339826,-0.0742264) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.214725,-0.177381) , 
4, 582.042, 1, 0, 0.275766,-0.105722) , 
7, 1.79168, 1, 0, 0.395253,-0.0476291) , 
4, 453.526, 1, 0, 0.5,0.00728774)    );
  // itree = 3
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.6831,0.0172128) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.757849,0.0961005) , 
9, -1.34632, 1, 0, 0.739703,0.075241) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.537036,-0.0702989) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.617474,0.0140177) , 
9, -0.449287, 1, 0, 0.586469,-0.0174102) , 
1, 27.9212, 1, 0, 0.68791,0.0439249) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.308872,-0.0606885) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.531533,0.105608) , 
9, -0.363675, 1, 0, 0.391243,0.00584462) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.261117,-0.121679) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.380315,-0.0191283) , 
10, 1.94491, 1, 0, 0.297879,-0.0747939) , 
9, 0.748029, 1, 0, 0.358723,-0.0222429) , 
1, 39.0226, 1, 0, 0.5,0.00615431)    );
  // itree = 4
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.58227,0.0469559) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.493986,-0.0199394) , 
9, 1.04729, 1, 0, 0.556503,0.0259148) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.26618,-0.0774842) , 
5, 167.62, 1, 0, 0.523302,0.0164867) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.378925,-0.0495879) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.286547,-0.139428) , 
7, 3.33023, 1, 0, 0.333974,-0.0761) , 
7, 3.09596, 1, 0, 0.5,0.00509136)    );
  // itree = 5
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.514457,0.0182567) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.692232,0.00754549) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.294716,-0.0813934) , 
1, 29.3281, 1, 0, 0.414608,-0.0437632) , 
10, -2.24389, 1, 0, 0.437747,-0.0298078) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.706852,0.109838) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.538932,0.0330235) , 
7, 2.2204, 1, 0, 0.638709,0.0756212) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.521079,0.00768407) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.375868,-0.056666) , 
3, 363.438, 1, 0, 0.469295,-0.0119986) , 
9, 0.363361, 1, 0, 0.532189,0.0205296) , 
9, -0.747937, 1, 0, 0.5,0.00337306)    );
  // itree = 6
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.672471,0.0707331) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.789067,0.0759453) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.529581,0.00304148) , 
1, 19.3717, 1, 0, 0.589718,0.017829) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.393068,-0.0231186) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.242606,-0.096288) , 
3, 513.535, 1, 0, 0.36419,-0.027651) , 
5, 83.9158, 1, 0, 0.481767,-0.0039404) , 
7, 0.882731, 1, 0, 0.5,0.00286264)    );
  // itree = 7
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.483415,-0.0157974) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.499991,0.000232378) , 
10, -0.149374, 1, 0, 0.492002,-0.00663951) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.706041,0.0773381) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.532894,0.046327) , 
5, 76.7933, 1, 0, 0.636472,0.0595632) , 
2, 42.5546, 1, 0, 0.570851,0.0294928) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.405274,-0.0606673) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.487801,0.0142228) , 
2, 51.5136, 1, 0, 0.445896,-0.0194796) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.665234,0.0517643) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.407235,-0.0125415) , 
7, 1.31748, 1, 0, 0.538971,0.0198934) , 
6, 119.851, 1, 0, 0.474474,-0.00739046) , 
3, 234.274, 1, 0, 0.5,0.00237835)    );
  // itree = 8
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.556932,-0.0207621) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.661631,0.0364609) , 
9, -1.34626, 1, 0, 0.636558,0.020709) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.282966,-0.0451327) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.392794,0.0202267) , 
6, 91.5016, 1, 0, 0.322598,-0.0158995) , 
1, 57.4486, 1, 0, 0.525469,0.00775569) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.277656,-0.0683765) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.430055,-0.0201072) , 
6, 120.108, 1, 0, 0.354816,-0.0319291) , 
3, 512.786, 1, 0, 0.5,0.00183301)    );
  // itree = 9
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.483234,-0.037973) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.424355,0.0035541) , 
8, -0.448792, 1, 0, 0.446165,-0.0101154) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.660416,0.0431768) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.289759,-0.0488585) , 
1, 91.3469, 1, 0, 0.602339,0.0267594) , 
9, -0.577008, 1, 0, 0.524565,0.00839597) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.709372,0.0084678) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.388557,-0.0629741) , 
1, 26.227, 1, 0, 0.497719,-0.0341676) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.238519,0.0441232) , 
1, 78.0152, 1, 0, 0.428963,-0.0181297) , 
9, 1.34641, 1, 0, 0.5,0.00158022)    );
  // itree = 10
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.579671,0.0408983) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.53268,0.0111871) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.466624,-0.0150698) , 
9, 0.448836, 1, 0, 0.506676,0.000808038) , 
8, -2.54307, 1, 0, 0.513352,0.00416205) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.283037,-0.0644937) , 
7, 3.34187, 1, 0, 0.5,0.0012612)    );
  // itree = 11
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.405481,-0.0474332) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.598325,0.0583231) , 
2, 40.6734, 1, 0, 0.455968,-0.015459) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.636722,0.0361951) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.44393,-0.00128202) , 
7, 2.34867, 1, 0, 0.558265,0.0181603) , 
2, 48.6784, 1, 0, 0.512957,0.00326995) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.322023,-0.0461912) , 
3, 652.043, 1, 0, 0.5,0.000816558)    );
  // itree = 12
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.800017,0.0287754) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.649445,-0.0379671) , 
1, 22.0904, 1, 0, 0.724423,-0.00596262) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.419085,0.00688068) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.455387,0.0587847) , 
0, 49.8017, 1, 0, 0.439885,0.0326526) , 
1, 38.4102, 1, 0, 0.570851,0.0148789) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.603858,0.00418583) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.267035,-0.0411456) , 
1, 61.2176, 1, 0, 0.481321,-0.00818073) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.599944,0.0353977) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.282123,0.0105525) , 
7, 2.01757, 1, 0, 0.436572,0.01861) , 
0, 110.57, 1, 0, 0.474474,-0.0040812) , 
3, 234.274, 1, 0, 0.5,0.00094054)    );
  // itree = 13
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.442749,-0.0707329) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.524458,-0.00323058) , 
0, 51.2384, 1, 0, 0.49243,-0.0244938) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.562687,0.00931754) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.232085,-0.0203586) , 
1, 58.4755, 1, 0, 0.432056,-0.000227637) , 
8, -0.448792, 1, 0, 0.454588,-0.00928403) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.718186,0.0597263) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.536878,0.00149186) , 
7, 2.44804, 1, 0, 0.659956,0.0348172) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.435177,0.00459893) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.515024,-0.0263468) , 
8, 0.448807, 1, 0, 0.465603,-0.00628567) , 
9, 0.406138, 1, 0, 0.52968,0.0072658) , 
9, -0.448744, 1, 0, 0.5,0.000724424)    );
  // itree = 14
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.796401,0.048044) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.487532,-0.00465895) , 
1, 13.6773, 1, 0, 0.51731,0.000151597) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.536565,0.0509467) , 
0, 128.983, 1, 0, 0.518419,0.00263234) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.207969,-0.0533517) , 
5, 209.472, 1, 0, 0.5,0.000735681)    );
  // itree = 15
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.688236,0.0430571) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.505057,0.0304609) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.529416,-0.00550935) , 
6, 56.6186, 1, 0, 0.524647,0.00126367) , 
7, 0.742199, 1, 0, 0.537367,0.0040811) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.44425,0.0204008) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.398671,-0.0565127) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.199102,0.0198819) , 
5, 126.224, 1, 0, 0.328353,-0.0271343) , 
6, 32.4262, 1, 0, 0.370912,-0.0112348) , 
7, 2.85004, 1, 0, 0.5,0.0006429)    );
  // itree = 16
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.567103,0.0236689) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.612751,0.00216425) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.277022,-0.018602) , 
1, 61.2176, 1, 0, 0.493708,-0.00334663) , 
8, -2.54303, 1, 0, 0.499648,-0.00137246) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.503451,0.021238) , 
10, 2.54315, 1, 0, 0.5,0.000428258)    );
  // itree = 17
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.686115,-0.00476417) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.484226,0.028046) , 
1, 39.6383, 1, 0, 0.638964,0.00283841) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.385751,-0.0405788) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.385886,-0.00628131) , 
0, 58.6798, 1, 0, 0.385816,-0.0207683) , 
1, 51.9718, 1, 0, 0.575894,-0.00304303) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.263235,0.0115793) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.410829,0.0720981) , 
6, 94.756, 1, 0, 0.313286,0.0258518) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.164813,-0.0348548) , 
5, 168.555, 1, 0, 0.262225,0.0110848) , 
1, 77.8712, 1, 0, 0.5,0.000375262)    );
  // itree = 18
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.460143,-0.0469475) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.526222,-0.0055427) , 
9, -1.04706, 1, 0, 0.50986,-0.0131677) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.517651,0.0208563) , 
0, 93.6994, 1, 0, 0.5113,-0.00753041) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.685772,0.0626768) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.312686,-0.0028596) , 
5, 112.748, 1, 0, 0.459992,0.0197768) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.520306,0.00274842) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.468047,-0.0319489) , 
9, 1.64557, 1, 0, 0.510689,-0.00309572) , 
8, 0.548632, 1, 0, 0.493296,0.00475161) , 
8, -0.747944, 1, 0, 0.5,0.000178066)    );
  // itree = 19
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.605872,-0.000610324) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.68078,0.0431888) , 
0, 69.5945, 1, 0, 0.626281,0.00994667) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.589119,0.0100931) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.31427,-0.0295473) , 
7, 1.14508, 1, 0, 0.412003,-0.00973306) , 
5, 116.917, 1, 0, 0.568069,0.0046004) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.597531,0.028706) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.292841,-0.0109753) , 
5, 71.4047, 1, 0, 0.458724,0.0105897) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.35449,-0.0505548) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.376723,0.0133788) , 
2, 76.2542, 1, 0, 0.363866,-0.0174978) , 
6, 43.5436, 1, 0, 0.403163,-0.00586203) , 
7, 2.35822, 1, 0, 0.5,0.00028177)    );
  // itree = 20
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.801511,0.0386619) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.694342,-0.00662813) , 
1, 11.2728, 1, 0, 0.713806,0.000732861) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.553681,-0.0474284) , 
1, 33.4706, 1, 0, 0.68791,-0.00631507) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.392451,0.0502979) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.351495,-0.00246037) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.38008,0.0316553) , 
10, 2.32947, 1, 0, 0.355313,0.00191735) , 
10, -2.54294, 1, 0, 0.358723,0.00557069) , 
1, 39.0226, 1, 0, 0.5,0.000469678)    );
  // itree = 21
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.659305,0.0248028) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.502854,0.00190867) , 
5, 63.098, 1, 0, 0.568228,0.00992847) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.555117,-0.000837672) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.356626,-0.0407784) , 
7, 2.85581, 1, 0, 0.512331,-0.00714632) , 
3, 280.686, 1, 0, 0.547723,0.00366467) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.408811,-0.048172) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.512381,-0.00250714) , 
10, -1.0473, 1, 0, 0.479717,-0.0141474) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.46379,-0.0138647) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.163958,0.0451618) , 
7, 1.7972, 1, 0, 0.292921,0.00585504) , 
5, 126.546, 1, 0, 0.407641,-0.00642939) , 
3, 373.53, 1, 0, 0.5,0.00022585)    );
  // itree = 22
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.560626,0.0121484) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.4673,-0.00836109) , 
8, -2.24386, 1, 0, 0.487119,-0.00285487) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.63064,0.0325015) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.289923,-0.0182491) , 
5, 156.991, 1, 0, 0.54504,0.0165948) , 
10, -0.363301, 1, 0, 0.506293,0.00358365) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.770885,0.0168724) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.490544,-0.0222824) , 
1, 18.8288, 1, 0, 0.55235,-0.0125179) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.271503,0.0254914) , 
1, 78.0152, 1, 0, 0.488856,-0.00587333) , 
10, 0.74801, 1, 0, 0.5,0.000170448)    );
  // itree = 23
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.388735,-0.0320062) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.58715,0.0292572) , 
2, 40.0625, 1, 0, 0.461304,-0.00708483) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.621139,0.0151393) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.425474,-0.00438629) , 
7, 2.35548, 1, 0, 0.534389,0.00542095) , 
2, 53.4796, 1, 0, 0.496383,-0.00108234) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.54162,0.0185133) , 
6, 179.692, 1, 0, 0.5,0.00019552)    );
  // itree = 24
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.719727,0.028615) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.385936,-0.0169518) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.316375,0.0095099) , 
8, -1.04737, 1, 0, 0.34035,-0.000355805) , 
1, 30.8474, 1, 0, 0.458197,0.00728249) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.572285,-0.0232473) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.509725,-0.00399755) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.515575,0.0276432) , 
10, 2.24396, 1, 0, 0.510391,-7.21545e-05) , 
5, 42.0638, 1, 0, 0.518493,-0.00273951) , 
6, 60.011, 1, 0, 0.5,0.000334299)    );
  // itree = 25
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.523903,0.00171285) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.337583,-0.0310584) , 
7, 3.08781, 1, 0, 0.499839,-0.00169226) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.527468,0.0531409) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.420177,-0.00927109) , 
0, 55.9305, 1, 0, 0.463638,0.0122141) , 
8, -0.349239, 1, 0, 0.487292,0.00312751) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.613478,-0.0141429) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.288971,-0.050233) , 
1, 53.1803, 1, 0, 0.480293,-0.0221981) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.678872,-0.0132041) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.437996,0.0226116) , 
1, 39.0226, 1, 0, 0.556341,0.00488299) , 
8, 1.84504, 1, 0, 0.526409,-0.00577585) , 
8, 1.04718, 1, 0, 0.5,0.000235118)    );
  // itree = 26
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.568396,0.0143487) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.598085,-0.0215088) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.42854,-0.0033532) , 
7, 1.38269, 1, 0, 0.46692,-0.00596569) , 
8, -2.24386, 1, 0, 0.479861,-0.00361964) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.686287,0.0465211) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.493842,-0.00657868) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.441597,0.0174442) , 
0, 110.57, 1, 0, 0.487073,-0.00286143) , 
9, 0.164005, 1, 0, 0.517119,0.00341252) , 
9, -0.149551, 1, 0, 0.5,0.000181465)    );
  // itree = 27
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.565353,0.00489569) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.498048,-0.021395) , 
3, 307.21, 1, 0, 0.549604,-0.000839085) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.679804,-3.71851e-06) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.402863,0.0449797) , 
1, 38.5956, 1, 0, 0.539639,0.0179158) , 
0, 89.3936, 1, 0, 0.547723,0.00270097) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.390683,-0.00929425) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.490264,0.0242281) , 
10, -0.235696, 1, 0, 0.418937,8.86017e-05) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.405531,-0.0250953) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.364964,-0.000267481) , 
9, 1.64538, 1, 0, 0.390047,-0.0120838) , 
10, 0.448531, 1, 0, 0.407641,-0.00467074) , 
3, 373.53, 1, 0, 0.5,0.000189591)    );
  // itree = 28
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.59311,-0.0312812) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.695572,0.0410883) , 
0, 61.8293, 1, 0, 0.648758,0.00707631) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.498936,0.00315701) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.441647,-0.0187527) , 
0, 70.2861, 1, 0, 0.478558,-0.00345509) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.391499,0.0274247) , 
2, 123.039, 1, 0, 0.470464,-0.00126251) , 
7, 1.12865, 1, 0, 0.5,0.000118873)    );
  // itree = 29
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.473958,0.0156768) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.455387,-0.0090473) , 
10, 1.6456, 1, 0, 0.469661,0.00768049) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.464814,-0.0120304) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.572096,0.00499362) , 
2, 48.6784, 1, 0, 0.529479,-0.00136595) , 
6, 54.9179, 1, 0, 0.512957,0.00113276) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.322023,-0.0199891) , 
3, 652.043, 1, 0, 0.5,0.000145516)    );
  // itree = 30
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.446723,0.0129614) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.271216,-0.0672523) , 
3, 339.866, 1, 0, 0.386329,-0.00832816) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.672429,0.0338668) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.50159,-0.00599287) , 
7, 1.86522, 1, 0, 0.573838,0.00897062) , 
2, 39.1612, 1, 0, 0.498737,0.00204208) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.550287,0.0252351) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.416771,-0.00847111) , 
0, 49.7073, 1, 0, 0.472381,0.00489012) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.602489,-0.0261635) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.420858,-0.00385351) , 
4, 668.299, 1, 0, 0.534229,-0.0144246) , 
6, 122.211, 1, 0, 0.503179,-0.00472807) , 
2, 78.0974, 1, 0, 0.5,0.000116785)    );
  // itree = 31
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.561962,-0.0214344) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.649678,0.00745445) , 
9, -1.64538, 1, 0, 0.632645,0.00139518) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.345924,-0.00504005) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.518539,-0.0390294) , 
0, 79.4397, 1, 0, 0.423539,-0.0160228) , 
5, 97.9643, 1, 0, 0.584021,-0.00265503) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.567426,-0.0124399) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.273563,0.0111152) , 
7, 1.56461, 1, 0, 0.380582,0.000605274) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.353155,0.00494026) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.532577,0.0294816) , 
6, 94.756, 1, 0, 0.444001,0.0151333) , 
8, 1.34627, 1, 0, 0.395253,0.00396628) , 
4, 453.526, 1, 0, 0.5,0.000292142)    );
  // itree = 32
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.521637,-0.00118703) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.71437,0.0302727) , 
9, -0.235053, 1, 0, 0.577092,0.00619206) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.343612,0.00432943) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.513122,-0.0224835) , 
9, -0.748032, 1, 0, 0.407819,-0.00542674) , 
7, 2.60893, 1, 0, 0.524147,0.00255793) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.739475,0.0144083) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.344012,-0.0268288) , 
1, 30.6283, 1, 0, 0.468009,-0.0109536) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.478676,-0.00540825) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.425428,0.0276569) , 
9, 2.11598, 1, 0, 0.457986,0.00524144) , 
0, 62.6366, 1, 0, 0.463415,-0.00353161) , 
9, 0.448836, 1, 0, 0.5,0.000136714)    );
  // itree = 33
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.436704,-0.014757) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.620158,0.0200758) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.296495,-0.000776925) , 
5, 71.4047, 1, 0, 0.462975,0.00857687) , 
10, -1.94458, 1, 0, 0.458197,0.00488254) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.603299,-0.0114577) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.386806,0.0475877) , 
1, 50.3024, 1, 0, 0.508417,0.0111756) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.557066,-0.00300173) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.208024,-0.0394289) , 
1, 116.723, 1, 0, 0.520607,-0.00452938) , 
10, -1.9447, 1, 0, 0.518493,-0.00180573) , 
6, 60.011, 1, 0, 0.5,0.000245603)    );
  // itree = 34
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.618895,-0.0036383) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.708665,0.0311744) , 
0, 69.598, 1, 0, 0.645776,0.00569955) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.509917,-0.00183933) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.450253,-0.0434378) , 
6, 94.2028, 1, 0, 0.500778,-0.00697125) , 
7, 1.86639, 1, 0, 0.561236,-0.00168806) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.461152,-0.0125028) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.248962,0.0411026) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.143412,0.00991853) , 
3, 441.428, 1, 0, 0.210172,0.016408) , 
7, 1.86474, 1, 0, 0.311548,0.00587103) , 
5, 125.768, 1, 0, 0.5,0.000165813)    );
  // itree = 35
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.490462,0.0080775) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.50309,-0.00631006) , 
10, -1.94397, 1, 0, 0.499635,-0.00168377) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.443802,0.0330297) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.507594,-0.0147627) , 
6, 115.486, 1, 0, 0.466341,0.0111217) , 
8, -0.363383, 1, 0, 0.489794,0.0021012) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.694397,0.00428436) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.361851,-0.0237892) , 
1, 40.66, 1, 0, 0.513541,-0.0088514) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.451008,-0.0167627) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.571869,0.0227202) , 
8, 1.65945, 1, 0, 0.522976,0.00676295) , 
0, 70.2884, 1, 0, 0.51689,-0.00330849) , 
8, 0.747994, 1, 0, 0.5,6.35875e-05)    );
  // itree = 36
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.746106,-0.000549188) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.796253,0.0296246) , 
5, 67.97, 1, 0, 0.772744,0.0114574) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.693379,0.00268313) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.560621,-0.0363242) , 
5, 68.8917, 1, 0, 0.639998,-0.0114839) , 
7, 1.62843, 1, 0, 0.68791,-0.00320378) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.551599,0.00684179) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.455796,-0.0239415) , 
7, 0.950249, 1, 0, 0.500693,-0.00829362) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.37434,0.0207469) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.274232,-0.00291051) , 
7, 2.36033, 1, 0, 0.317126,0.00576193) , 
7, 1.36979, 1, 0, 0.358723,0.00257691) , 
1, 39.0226, 1, 0, 0.5,9.60156e-05)    );
  // itree = 37
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.51158,-0.0128391) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.355494,0.0047482) , 
7, 2.11927, 1, 0, 0.42817,-0.00319395) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.61915,0.023251) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.542883,-7.17538e-05) , 
5, 39.1136, 1, 0, 0.554746,0.00311135) , 
9, -1.08997, 1, 0, 0.512694,0.00101658) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.521165,-0.0206108) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.269421,0.0188761) , 
5, 107.073, 1, 0, 0.41845,-0.00576625) , 
9, 2.24399, 1, 0, 0.5,0.000102962)    );
  // itree = 38
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.651489,0.0203814) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.644091,-0.0138497) , 
2, 78.0974, 1, 0, 0.648758,0.00608332) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.380744,-0.0205529) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.493094,-0.00138117) , 
9, -2.24389, 1, 0, 0.478558,-0.00289967) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.391499,0.0213737) , 
2, 123.039, 1, 0, 0.470464,-0.00115281) , 
7, 1.12865, 1, 0, 0.5,4.5905e-05)    );
  // itree = 39
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.416382,0.00987138) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.383777,-0.013733) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.540772,0.00309653) , 
2, 34.5805, 1, 0, 0.514958,0.000329317) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.442658,-0.013792) , 
2, 126.195, 1, 0, 0.508323,-0.000687518) , 
9, -2.5431, 1, 0, 0.5,4.84957e-05)    );
  // itree = 40
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.55682,-0.00132185) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.557855,0.0175984) , 
3, 362.952, 1, 0, 0.556954,0.000987678) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.400087,-0.0256468) , 
4, 538.781, 1, 0, 0.541206,-0.0010421) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.500937,0.00962343) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.207337,-0.0224151) , 
7, 1.99276, 1, 0, 0.362375,-0.00192622) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.289449,0.0372038) , 
9, 1.34641, 1, 0, 0.343849,0.0042071) , 
4, 602.735, 1, 0, 0.5,5.38771e-05)    );
  // itree = 41
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.463902,-0.00688178) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.463678,0.0052528) , 
0, 53.7726, 1, 0, 0.463772,6.1672e-05) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.756914,0.0409254) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.581038,-0.0135718) , 
7, 1.99276, 1, 0, 0.675471,0.0112342) , 
9, -0.320531, 1, 0, 0.509902,0.00249622) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.652071,0.00200762) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.468619,-0.0311256) , 
5, 100.256, 1, 0, 0.58706,-0.0074987) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.414424,0.00515444) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.44483,-0.0147343) , 
8, 0.44825, 1, 0, 0.421199,0.000444186) , 
7, 1.85923, 1, 0, 0.48849,-0.00277832) , 
9, 0.149642, 1, 0, 0.5,5.69725e-05)    );
  // itree = 42
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.657371,0.0158269) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.616487,-0.00446335) , 
0, 58.6696, 1, 0, 0.636412,0.00445165) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.258451,0.0229524) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.328564,-0.0139406) , 
9, -2.073, 1, 0, 0.311101,-0.0042764) , 
1, 60.7794, 1, 0, 0.524565,0.0014508) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.563709,-0.0182065) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.324295,0.0175157) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.391432,-0.0174922) , 
8, 0.44724, 1, 0, 0.346822,0.00363831) , 
5, 71.6596, 1, 0, 0.428963,-0.00374409) , 
9, 1.34641, 1, 0, 0.5,0.000115983)    );
  // itree = 43
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.506265,0.0208374) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.573281,-0.00263616) , 
6, 67.366, 1, 0, 0.560775,0.00132753) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.407884,-0.0187807) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.374304,-0.00289723) , 
8, -0.74797, 1, 0, 0.390795,-0.00813708) , 
7, 2.4805, 1, 0, 0.498439,-0.00214336) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.502518,0.00537725) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.466872,-0.00969502) , 
10, 2.00179, 1, 0, 0.491384,0.000263344) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.577728,0.0223351) , 
8, 2.54312, 1, 0, 0.501746,0.00258957) , 
10, 0.149629, 1, 0, 0.5,9.04843e-05)    );
  // itree = 44
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.544749,-0.0112854) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.637572,0.00649173) , 
9, -1.31794, 1, 0, 0.610138,0.000785791) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.545226,-0.0166645) , 
9, 1.64561, 1, 0, 0.597452,-0.0022066) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.403368,0.0347641) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.385375,-0.00644276) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.45875,0.023855) , 
8, 1.34531, 1, 0, 0.397099,-0.000756635) , 
10, -1.94403, 1, 0, 0.397848,0.00248706) , 
5, 83.9158, 1, 0, 0.5,8.49659e-05)    );
  // itree = 45
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.550927,-0.0395271) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.615046,0.00812561) , 
0, 43.6435, 1, 0, 0.584253,-0.0118847) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.722284,0.0360797) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.632372,0.00904077) , 
3, 366.25, 1, 0, 0.676191,0.0178608) , 
0, 61.8284, 1, 0, 0.632111,0.0035991) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.440682,0.00691402) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.511049,-0.00873224) , 
8, 1.34641, 1, 0, 0.461744,0.00147489) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.658346,-0.0356161) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.352445,0.00286551) , 
1, 30.7161, 1, 0, 0.446218,-0.00736163) , 
6, 94.2028, 1, 0, 0.457226,-0.00109652) , 
7, 1.37456, 1, 0, 0.5,5.19515e-05)    );
  // itree = 46
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.670036,0.00701489) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.446768,-0.0178417) , 
1, 46.3471, 1, 0, 0.623309,0.001333) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.379953,0.0131403) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.266119,-0.0148319) , 
8, -1.64523, 1, 0, 0.287807,-0.00564643) , 
1, 60.7794, 1, 0, 0.503217,-0.00116526) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.459758,-0.0210893) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.429967,0.0051642) , 
7, 2.60917, 1, 0, 0.444844,-0.00667381) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.543263,0.0212593) , 
6, 86.9166, 1, 0, 0.488589,0.00437105) , 
10, 1.64558, 1, 0, 0.5,5.23054e-05)    );
  // itree = 47
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.817691,0.0325688) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.747249,-0.00490755) , 
0, 61.8345, 1, 0, 0.783361,0.00979886) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.682184,-0.0208195) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.586677,0.0057528) , 
4, 433.109, 1, 0, 0.645267,-0.00869515) , 
1, 16.8224, 1, 0, 0.68791,-0.00298422) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.44264,0.00848249) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.258058,-0.00799269) , 
1, 67.6967, 1, 0, 0.341043,0.000363866) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.496142,0.0356288) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.3643,-0.0113597) , 
7, 2.21731, 1, 0, 0.427705,0.0110492) , 
8, 1.64544, 1, 0, 0.358723,0.00254376) , 
1, 39.0226, 1, 0, 0.5,0.00017132)    );
  // itree = 48
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.691615,-0.000735472) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.52195,0.0271689) , 
1, 38.227, 1, 0, 0.666228,0.00309424) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.412913,-0.0262879) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.405871,-0.00495508) , 
8, -1.34661, 1, 0, 0.407852,-0.00926793) , 
1, 44.5721, 1, 0, 0.575894,-0.00122785) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.355303,0.0300249) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.19547,-0.0176524) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.342423,0.0281457) , 
8, 1.21823, 1, 0, 0.237722,-0.000571102) , 
8, -1.34637, 1, 0, 0.262225,0.00443964) , 
1, 77.8712, 1, 0, 0.5,0.000143427)    );
  // itree = 49
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.591932,0.00559576) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.554382,-0.00910924) , 
8, 1.34637, 1, 0, 0.578574,0.000211679) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.4258,-0.0207369) , 
5, 107.831, 1, 0, 0.561236,-0.00165038) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.204363,0.000301565) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.227754,0.0348799) , 
10, -0.448502, 1, 0, 0.218944,0.0119189) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.37102,-0.0260582) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.494585,0.0176647) , 
6, 174.714, 1, 0, 0.431744,-0.00283481) , 
6, 120.607, 1, 0, 0.311548,0.00549858) , 
5, 125.768, 1, 0, 0.5,0.000102903)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
