// Class: ReadBDT
// Automatically generated by MethodBase::MakeClass
//

/* configuration options =====================================================

#GEN -*-*-*-*-*-*-*-*-*-*-*- general info -*-*-*-*-*-*-*-*-*-*-*-

Method         : BDT::BDT
TMVA Release   : 4.2.1         [262657]
ROOT Release   : 6.10/04       [395780]
Creator        : marine5575
Date           : Wed Oct  9 19:50:29 2019
Host           : Linux htop.hanyang.ac.kr 2.6.32-696.el6.centos.plus.x86_64 #1 SMP Mon Apr 3 14:56:08 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux
Dir            : /home/marine5575/work/Undergrad2018/mva
Training events: 50004
Analysis type  : [Classification]


#OPT -*-*-*-*-*-*-*-*-*-*-*-*- options -*-*-*-*-*-*-*-*-*-*-*-*-

# Set by User:
V: "False" [Verbose output (short form of "VerbosityLevel" below - overrides the latter one)]
H: "False" [Print method-specific help message]
NTrees: "50" [Number of trees in the forest]
MaxDepth: "3" [Max depth of the decision tree allowed]
MinNodeSize: "5%" [Minimum percentage of training events required in a leaf node (default: Classification: 5%, Regression: 0.2%)]
nCuts: "10" [Number of grid points in variable range used in finding optimal cut in node splitting]
BoostType: "Grad" [Boosting type for the trees in the forest (note: AdaCost is still experimental)]
Shrinkage: "5.000000e-01" [Learning rate for GradBoost algorithm]
SeparationType: "giniindex" [Separation criterion for node splitting]
# Default:
VerbosityLevel: "Default" [Verbosity level]
VarTransform: "None" [List of variable transformations performed before training, e.g., "D_Background,P_Signal,G,N_AllClasses" for: "Decorrelation, PCA-transformation, Gaussianisation, Normalisation, each for the given class of events ('AllClasses' denotes all events of all classes, if no class indication is given, 'All' is assumed)"]
CreateMVAPdfs: "False" [Create PDFs for classifier outputs (signal and background)]
IgnoreNegWeightsInTraining: "False" [Events with negative weights are ignored in the training (but are included for testing and performance evaluation)]
AdaBoostR2Loss: "quadratic" [Type of Loss function in AdaBoostR2]
UseBaggedBoost: "False" [Use only a random subsample of all events for growing the trees in each boost iteration.]
AdaBoostBeta: "5.000000e-01" [Learning rate  for AdaBoost algorithm]
UseRandomisedTrees: "False" [Determine at each node splitting the cut variable only as the best out of a random subset of variables (like in RandomForests)]
UseNvars: "3" [Size of the subset of variables used with RandomisedTree option]
UsePoissonNvars: "True" [Interpret "UseNvars" not as fixed number but as mean of a Poisson distribution in each split with RandomisedTree option]
BaggedSampleFraction: "6.000000e-01" [Relative size of bagged event sample to original size of the data sample (used whenever bagging is used (i.e. UseBaggedBoost, Bagging,)]
UseYesNoLeaf: "True" [Use Sig or Bkg categories, or the purity=S/(S+B) as classification of the leaf node -> Real-AdaBoost]
NegWeightTreatment: "pray" [How to treat events with negative weights in the BDT training (particular the boosting) : IgnoreInTraining;  Boost With inverse boostweight; Pair events with negative and positive weights in training sample and *annihilate* them (experimental!)]
Css: "1.000000e+00" [AdaCost: cost of true signal selected signal]
Cts_sb: "1.000000e+00" [AdaCost: cost of true signal selected bkg]
Ctb_ss: "1.000000e+00" [AdaCost: cost of true bkg    selected signal]
Cbb: "1.000000e+00" [AdaCost: cost of true bkg    selected bkg ]
NodePurityLimit: "5.000000e-01" [In boosting/pruning, nodes with purity > NodePurityLimit are signal; background otherwise.]
RegressionLossFunctionBDTG: "huber" [Loss function for BDTG regression.]
HuberQuantile: "7.000000e-01" [In the Huber loss function this is the quantile that separates the core from the tails in the residuals distribution.]
DoBoostMonitor: "False" [Create control plot with ROC integral vs tree number]
UseFisherCuts: "False" [Use multivariate splits using the Fisher criterion]
MinLinCorrForFisher: "8.000000e-01" [The minimum linear correlation between two variables demanded for use in Fisher criterion in node splitting]
UseExclusiveVars: "False" [Variables already used in fisher criterion are not anymore analysed individually for node splitting]
DoPreselection: "False" [and and apply automatic pre-selection for 100% efficient signal (bkg) cuts prior to training]
SigToBkgFraction: "1.000000e+00" [Sig to Bkg ratio used in Training (similar to NodePurityLimit, which cannot be used in real adaboost]
PruneMethod: "nopruning" [Note: for BDTs use small trees (e.g.MaxDepth=3) and NoPruning:  Pruning: Method used for pruning (removal) of statistically insignificant branches ]
PruneStrength: "0.000000e+00" [Pruning strength]
PruningValFraction: "5.000000e-01" [Fraction of events to use for optimizing automatic pruning.]
SkipNormalization: "False" [Skip normalization at initialization, to keep expectation value of BDT output according to the fraction of events]
nEventsMin: "0" [deprecated: Use MinNodeSize (in % of training events) instead]
UseBaggedGrad: "False" [deprecated: Use *UseBaggedBoost* instead:  Use only a random subsample of all events for growing the trees in each iteration.]
GradBaggingFraction: "6.000000e-01" [deprecated: Use *BaggedSampleFraction* instead: Defines the fraction of events to be used in each iteration, e.g. when UseBaggedGrad=kTRUE. ]
UseNTrainEvents: "0" [deprecated: Use *BaggedSampleFraction* instead: Number of randomly picked training events used in randomised (and bagged) trees]
NNodesMax: "0" [deprecated: Use MaxDepth instead to limit the tree size]
##


#VAR -*-*-*-*-*-*-*-*-*-*-*-* variables *-*-*-*-*-*-*-*-*-*-*-*-

NVar 11
lepton1_pt                    lepton1_pt                    lepton1_pt                    lepton1_pt                                                      'F'    [30.0003757477,715.323425293]
met_pt                        met_pt                        met_pt                        met_pt                                                          'F'    [0.19669675827,832.46496582]
tau1_pt                       tau1_pt                       tau1_pt                       tau1_pt                                                         'F'    [30.0003395081,1108.22265625]
jet_ht                        jet_ht                        jet_ht                        jet_ht                                                          'F'    [95.0174484253,2866.1184082]
jetlepmet_ht                  jetlepmet_ht                  jetlepmet_ht                  jetlepmet_ht                                                    'F'    [144.123748779,3074.10449219]
lep1met_pt                    lep1met_pt                    lep1met_pt                    lep1met_pt                                                      'F'    [0.211814135313,920.750061035]
lep1tau1_pt                   lep1tau1_pt                   lep1tau1_pt                   lep1tau1_pt                                                     'F'    [0.167901813984,1148.01318359]
tau1_lep1_dr                  tau1_lep1_dr                  tau1_lep1_dr                  tau1_lep1_dr                                                    'F'    [0.390903234482,5.5550994873]
lep1_met_dphi                 lep1_met_dphi                 lep1_met_dphi                 lep1_met_dphi                                                   'F'    [-3.14144611359,3.1415913105]
tau1_met_dphi                 tau1_met_dphi                 tau1_met_dphi                 tau1_met_dphi                                                   'F'    [-3.14137792587,3.14126992226]
tau1lep1_met_dphi             tau1lep1_met_dphi             tau1lep1_met_dphi             tau1lep1_met_dphi                                               'F'    [-3.14146351814,3.14153146744]
NSpec 2
njet                          njet                          njet                          njet                                                            'F'    [3,12]
nbjet                         nbjet                         nbjet                         nbjet                                                           'F'    [0,6]


============================================================================ */

#include <vector>
#include <cmath>
#include <string>
#include <iostream>

#define NN new BDTNode
   
#ifndef BDTNode__def
#define BDTNode__def
   
class BDTNode {
   
public:
   
   // constructor of an essentially "empty" node floating in space
   BDTNode ( BDTNode* left,BDTNode* right,
                          int selector, double cutValue, bool cutType, 
                          int nodeType, double purity, double response ) :
   fLeft         ( left         ),
   fRight        ( right        ),
   fSelector     ( selector     ),
   fCutValue     ( cutValue     ),
   fCutType      ( cutType      ),
   fNodeType     ( nodeType     ),
   fPurity       ( purity       ),
   fResponse     ( response     ){
   }

   virtual ~BDTNode();

   // test event if it descends the tree at this node to the right
   virtual bool GoesRight( const std::vector<double>& inputValues ) const;
   BDTNode* GetRight( void )  {return fRight; };

   // test event if it descends the tree at this node to the left 
   virtual bool GoesLeft ( const std::vector<double>& inputValues ) const;
   BDTNode* GetLeft( void ) { return fLeft; };   

   // return  S/(S+B) (purity) at this node (from  training)

   double GetPurity( void ) const { return fPurity; } 
   // return the node type
   int    GetNodeType( void ) const { return fNodeType; }
   double GetResponse(void) const {return fResponse;}

private:

   BDTNode*   fLeft;     // pointer to the left daughter node
   BDTNode*   fRight;    // pointer to the right daughter node
   int                     fSelector; // index of variable used in node selection (decision tree)   
   double                  fCutValue; // cut value applied on this node to discriminate bkg against sig
   bool                    fCutType;  // true: if event variable > cutValue ==> signal , false otherwise
   int                     fNodeType; // Type of node: -1 == Bkg-leaf, 1 == Signal-leaf, 0 = internal 
   double                  fPurity;   // Purity of node from training
   double                  fResponse; // Regression response value of node
}; 
   
//_______________________________________________________________________
   BDTNode::~BDTNode()
{
   if (fLeft  != NULL) delete fLeft;
   if (fRight != NULL) delete fRight;
}; 
   
//_______________________________________________________________________
bool BDTNode::GoesRight( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the right
   bool result;
     result = (inputValues[fSelector] > fCutValue );
   if (fCutType == true) return result; //the cuts are selecting Signal ;
   else return !result;
}
   
//_______________________________________________________________________
bool BDTNode::GoesLeft( const std::vector<double>& inputValues ) const
{
   // test event if it descends the tree at this node to the left
   if (!this->GoesRight(inputValues)) return true;
   else return false;
}
   
#endif
   
#ifndef IClassifierReader__def
#define IClassifierReader__def

class IClassifierReader {

 public:

   // constructor
   IClassifierReader() : fStatusIsClean( true ) {}
   virtual ~IClassifierReader() {}

   // return classifier response
   virtual double GetMvaValue( const std::vector<double>& inputValues ) const = 0;

   // returns classifier status
   bool IsStatusClean() const { return fStatusIsClean; }

 protected:

   bool fStatusIsClean;
};

#endif

class ReadBDT : public IClassifierReader {

 public:

   // constructor
   ReadBDT( std::vector<std::string>& theInputVars ) 
      : IClassifierReader(),
        fClassName( "ReadBDT" ),
        fNvars( 11 ),
        fIsNormalised( false )
   {      
      // the training input variables
      const char* inputVars[] = { "lepton1_pt", "met_pt", "tau1_pt", "jet_ht", "jetlepmet_ht", "lep1met_pt", "lep1tau1_pt", "tau1_lep1_dr", "lep1_met_dphi", "tau1_met_dphi", "tau1lep1_met_dphi" };

      // sanity checks
      if (theInputVars.size() <= 0) {
         std::cout << "Problem in class \"" << fClassName << "\": empty input vector" << std::endl;
         fStatusIsClean = false;
      }

      if (theInputVars.size() != fNvars) {
         std::cout << "Problem in class \"" << fClassName << "\": mismatch in number of input values: "
                   << theInputVars.size() << " != " << fNvars << std::endl;
         fStatusIsClean = false;
      }

      // validate input variables
      for (size_t ivar = 0; ivar < theInputVars.size(); ivar++) {
         if (theInputVars[ivar] != inputVars[ivar]) {
            std::cout << "Problem in class \"" << fClassName << "\": mismatch in input variable names" << std::endl
                      << " for variable [" << ivar << "]: " << theInputVars[ivar].c_str() << " != " << inputVars[ivar] << std::endl;
            fStatusIsClean = false;
         }
      }

      // initialize min and max vectors (for normalisation)
      fVmin[0] = 0;
      fVmax[0] = 0;
      fVmin[1] = 0;
      fVmax[1] = 0;
      fVmin[2] = 0;
      fVmax[2] = 0;
      fVmin[3] = 0;
      fVmax[3] = 0;
      fVmin[4] = 0;
      fVmax[4] = 0;
      fVmin[5] = 0;
      fVmax[5] = 0;
      fVmin[6] = 0;
      fVmax[6] = 0;
      fVmin[7] = 0;
      fVmax[7] = 0;
      fVmin[8] = 0;
      fVmax[8] = 0;
      fVmin[9] = 0;
      fVmax[9] = 0;
      fVmin[10] = 0;
      fVmax[10] = 0;

      // initialize input variable types
      fType[0] = 'F';
      fType[1] = 'F';
      fType[2] = 'F';
      fType[3] = 'F';
      fType[4] = 'F';
      fType[5] = 'F';
      fType[6] = 'F';
      fType[7] = 'F';
      fType[8] = 'F';
      fType[9] = 'F';
      fType[10] = 'F';

      // initialize constants
      Initialize();

   }

   // destructor
   virtual ~ReadBDT() {
      Clear(); // method-specific
   }

   // the classifier response
   // "inputValues" is a vector of input values in the same order as the 
   // variables given to the constructor
   double GetMvaValue( const std::vector<double>& inputValues ) const;

 private:

   // method-specific destructor
   void Clear();

   // common member variables
   const char* fClassName;

   const size_t fNvars;
   size_t GetNvar()           const { return fNvars; }
   char   GetType( int ivar ) const { return fType[ivar]; }

   // normalisation of input variables
   const bool fIsNormalised;
   bool IsNormalised() const { return fIsNormalised; }
   double fVmin[11];
   double fVmax[11];
   double NormVariable( double x, double xmin, double xmax ) const {
      // normalise to output range: [-1, 1]
      return 2*(x - xmin)/(xmax - xmin) - 1.0;
   }

   // type of input variable: 'F' or 'I'
   char   fType[11];

   // initialize internal variables
   void Initialize();
   double GetMvaValue__( const std::vector<double>& inputValues ) const;

   // private members (method specific)
   std::vector<BDTNode*> fForest;       // i.e. root nodes of decision trees
   std::vector<double>                fBoostWeights; // the weights applied in the individual boosts
};

double ReadBDT::GetMvaValue__( const std::vector<double>& inputValues ) const
{
   double myMVA = 0;
   for (unsigned int itree=0; itree<fForest.size(); itree++){
      BDTNode *current = fForest[itree];
      while (current->GetNodeType() == 0) { //intermediate node
         if (current->GoesRight(inputValues)) current=(BDTNode*)current->GetRight();
         else current=(BDTNode*)current->GetLeft();
      }
      myMVA += current->GetResponse();
   }
   return 2.0/(1.0+exp(-2.0*myMVA))-1.0;
};

void ReadBDT::Initialize()
{
  // itree = 0
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.485511,-0.0103719) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.626944,0.078592) , 
2, 38.7064, 1, 0, 0.53212,0.0321195) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.718829,0.124547) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.619755,0.074654) , 
4, 320.666, 1, 0, 0.660714,0.160714) , 
2, 45.9627, 1, 0, 0.601255,0.101255) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.557493,0.0381236) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.489748,-0.00730464) , 
7, 0.902989, 1, 0, 0.520334,0.020334) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.424041,-0.0583337) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.303399,-0.176166) , 
4, 652.639, 1, 0, 0.388912,-0.111087) , 
7, 1.32985, 1, 0, 0.417335,-0.0826654) , 
4, 410.486, 1, 0, 0.5,-4.28684e-15)    );
  // itree = 1
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.598297,0.0561978) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.47182,-0.0268954) , 
4, 313.624, 1, 0, 0.53212,0.022673) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.70318,0.0863708) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.606314,0.0438565) , 
4, 343.12, 1, 0, 0.660714,0.113247) , 
2, 45.9627, 1, 0, 0.601255,0.0713676) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.328118,-0.121505) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.35784,-0.0791606) , 
7, 2.56987, 1, 0, 0.342036,-0.117962) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.489542,0.0136703) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.368533,-0.0773816) , 
9, 1.06452, 1, 0, 0.441403,-0.0256539) , 
9, -1.42768, 1, 0, 0.417335,-0.0480122) , 
4, 410.486, 1, 0, 0.5,0.00564462)    );
  // itree = 2
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.566539,0.0108712) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.725958,0.101915) , 
8, -0.597103, 1, 0, 0.627135,0.0773865) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.453529,-0.0453754) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.627577,0.0303699) , 
2, 44.061, 1, 0, 0.554221,0.00194472) , 
8, 0.85685, 1, 0, 0.601255,0.0506093) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.386124,-0.0466118) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.525412,0.0550145) , 
8, -0.233688, 1, 0, 0.441665,-0.00284733) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.376747,-0.0543524) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.314986,-0.123227) , 
9, 0.285107, 1, 0, 0.355755,-0.0902193) , 
8, 0.856709, 1, 0, 0.417335,-0.0275917) , 
4, 410.486, 1, 0, 0.5,0.00755676)    );
  // itree = 3
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.415478,-0.052424) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.604666,0.0468097) , 
2, 40.6254, 1, 0, 0.497027,-0.00708353) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.59067,0.052509) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.525605,0.0166015) , 
8, 0.856688, 1, 0, 0.569113,0.0609088) , 
2, 59.2204, 1, 0, 0.527272,0.0214441) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.375245,-0.0346145) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.300622,-0.0983574) , 
8, 0.285464, 1, 0, 0.345789,-0.0657705) , 
4, 676.848, 1, 0, 0.5,0.00833803)    );
  // itree = 4
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.673193,0.0565991) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.56572,0.021365) , 
4, 296.12, 1, 0, 0.597311,0.0488655) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.35848,-0.0562981) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.431574,0.00172469) , 
8, -0.8569, 1, 0, 0.407013,-0.0205999) , 
3, 346.936, 1, 0, 0.535673,0.0263653) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.554392,0.0359245) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.421176,-0.0296276) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.293271,-0.0980498) , 
1, 144.643, 1, 0, 0.395369,-0.0502429) , 
7, 1.29133, 1, 0, 0.426697,-0.0298637) , 
1, 75.8574, 1, 0, 0.5,0.00795896)    );
  // itree = 5
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.403784,-0.0708622) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.523562,0.0200108) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.437965,-0.040854) , 
9, 1.32424, 1, 0, 0.488252,-0.00477447) , 
9, -0.856716, 1, 0, 0.46697,-0.025317) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.653022,0.0819207) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.413776,-0.0312356) , 
0, 81.0429, 1, 0, 0.584527,0.0812837) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.476744,-0.00778568) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.397426,-0.0661404) , 
9, 0.856702, 1, 0, 0.455892,-0.0283726) , 
8, 0.597261, 1, 0, 0.515728,0.0226351) , 
8, -0.856705, 1, 0, 0.5,0.00716718)    );
  // itree = 6
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.612516,0.0317192) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.554136,-0.00072427) , 
9, 1.42781, 1, 0, 0.597311,0.0351337) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.441237,0.00687893) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.335052,-0.0457615) , 
8, 0.856466, 1, 0, 0.407013,-0.0101678) , 
3, 346.936, 1, 0, 0.535673,0.0204603) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.394463,-0.0384907) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.343972,-0.0744584) , 
8, 0.28355, 1, 0, 0.370136,-0.0637147) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.523595,0.0325812) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.377986,-0.0421254) , 
9, 0.960994, 1, 0, 0.454392,0.000664031) , 
9, -0.856475, 1, 0, 0.426697,-0.0204975) , 
1, 75.8574, 1, 0, 0.5,0.00705293)    );
  // itree = 7
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.461717,-0.0273608) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.563877,0.0192868) , 
2, 54.5903, 1, 0, 0.508401,-0.00676787) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.30053,-0.0707811) , 
3, 425.858, 1, 0, 0.46697,-0.0199636) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.653022,0.0583061) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.413776,-0.0179461) , 
0, 81.0429, 1, 0, 0.584527,0.0577832) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.518845,0.0104456) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.407396,-0.0322432) , 
1, 47.3891, 1, 0, 0.455892,-0.015693) , 
8, 0.597261, 1, 0, 0.515728,0.0184852) , 
8, -0.856705, 1, 0, 0.5,0.00608275)    );
  // itree = 8
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.485351,-0.011112) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.275387,-0.11123) , 
4, 409.51, 1, 0, 0.382484,-0.0621214) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.508497,-0.00764802) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.566233,0.0253972) , 
9, -1.99908, 1, 0, 0.556502,0.0282663) , 
2, 38.9109, 1, 0, 0.502847,0.000397285) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.47453,0.0430134) , 
2, 128.021, 1, 0, 0.5,0.00589498)    );
  // itree = 9
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.485664,-0.015109) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.358958,-0.078755) , 
5, 92.2407, 1, 0, 0.4313,-0.0487763) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.582775,0.0406428) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.466934,-0.0116923) , 
9, 0.648808, 1, 0, 0.502352,0.00781619) , 
9, -0.28576, 1, 0, 0.47732,-0.0121221) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.727548,0.0856335) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.56807,0.0319903) , 
7, 2.15863, 1, 0, 0.655004,0.0957008) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.533958,0.00903263) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.417672,-0.0204071) , 
1, 46.9747, 1, 0, 0.466239,-0.00912996) , 
8, 0.337614, 1, 0, 0.517306,0.01923) , 
8, -0.28552, 1, 0, 0.5,0.00566099)    );
  // itree = 10
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.699699,0.044836) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.625677,0.0159495) , 
1, 30.4069, 1, 0, 0.650721,0.0388375) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.434956,-0.0156355) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.522157,0.0187212) , 
2, 65.6588, 1, 0, 0.471505,-0.000429622) , 
4, 328.088, 1, 0, 0.516531,0.00943575) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.334785,-0.0347653) , 
3, 598.854, 1, 0, 0.5,0.0053149)    );
  // itree = 11
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.420515,-0.0288268) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.502221,0.00175892) , 
8, -0.285604, 1, 0, 0.474199,-0.0102613) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.702887,0.0644777) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.536169,0.0202031) , 
7, 1.27061, 1, 0, 0.579408,0.046939) , 
9, -0.597197, 1, 0, 0.517575,0.0133215) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.412437,-0.0304669) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.558661,0.0198137) , 
10, 0.286077, 1, 0, 0.49239,-0.00149927) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.394874,-0.0498353) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.440249,-0.00683473) , 
10, 1.86651, 1, 0, 0.415901,-0.0344817) , 
8, 0.285209, 1, 0, 0.466339,-0.0127327) , 
9, 0.856671, 1, 0, 0.5,0.00438437)    );
  // itree = 12
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.530412,0.0128849) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.467379,-0.0078275) , 
8, 1.42804, 1, 0, 0.516146,0.0110538) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.349262,-0.0381599) , 
1, 151.518, 1, 0, 0.506332,0.00805597) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.44672,-0.0256187) , 
7, 3.20774, 1, 0, 0.5,0.00385015)    );
  // itree = 13
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.505011,-0.00257237) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.595872,0.0304809) , 
8, -1.06488, 1, 0, 0.53023,0.00939693) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.455101,-0.0126498) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.31541,-0.0662056) , 
1, 110.745, 1, 0, 0.415698,-0.0306017) , 
1, 58.1619, 1, 0, 0.47732,-0.00908135) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.727548,0.0577673) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.56807,0.0192905) , 
7, 2.15863, 1, 0, 0.655004,0.0596719) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.522907,0.0113219) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.440991,-0.0123065) , 
10, 0.285625, 1, 0, 0.466239,-0.00577523) , 
8, 0.337614, 1, 0, 0.517306,0.0119302) , 
8, -0.28552, 1, 0, 0.5,0.00283654)    );
  // itree = 14
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.436491,0.00213133) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.354857,-0.0457748) , 
7, 1.80573, 1, 0, 0.382484,-0.0323369) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.5748,0.0166111) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.52015,-0.00210301) , 
9, 0.856671, 1, 0, 0.556502,0.01433) , 
2, 38.9109, 1, 0, 0.502847,-5.8687e-05) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.47453,0.0233663) , 
2, 128.021, 1, 0, 0.5,0.00291416)    );
  // itree = 15
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.569071,0.0202535) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.49556,-0.0114931) , 
0, 44.4825, 1, 0, 0.521686,0.000243432) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.425204,-0.000537229) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.526369,0.0669256) , 
7, 2.60776, 1, 0, 0.477292,0.0466702) , 
0, 109.665, 1, 0, 0.516531,0.00563487) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.334785,-0.027805) , 
3, 598.854, 1, 0, 0.5,0.0025928)    );
  // itree = 16
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.420307,-0.0181526) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.528295,0.0124714) , 
8, -0.235307, 1, 0, 0.477445,-0.00144002) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.44418,-0.0301577) , 
8, 1.42562, 1, 0, 0.46912,-0.0103586) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.53148,-0.00105942) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.589544,0.0259243) , 
10, -0.284795, 1, 0, 0.568045,0.0221878) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.461293,-0.00816682) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.47323,0.0113077) , 
2, 96.9685, 1, 0, 0.463721,-0.00507842) , 
9, 0.960634, 1, 0, 0.516171,0.00862991) , 
9, -0.856779, 1, 0, 0.5,0.00210368)    );
  // itree = 17
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.666258,0.024822) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.529722,-0.0075157) , 
4, 294.632, 1, 0, 0.563992,0.00160368) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.555566,0.0462114) , 
0, 105.586, 1, 0, 0.563083,0.00846702) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.465369,0.0257708) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.388644,-0.0194799) , 
0, 46.9933, 1, 0, 0.421241,0.00079638) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.340474,-0.0343116) , 
0, 92.3042, 1, 0, 0.400017,-0.00887779) , 
3, 346.936, 1, 0, 0.5,0.00175706)    );
  // itree = 18
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.46978,-0.00645708) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.631069,0.0309363) , 
8, -0.64902, 1, 0, 0.531159,0.0111613) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.501827,0.0008938) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.353325,-0.0269796) , 
1, 93.7526, 1, 0, 0.472544,-0.00472194) , 
8, 0.285665, 1, 0, 0.506332,0.00443381) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.44672,-0.0168511) , 
7, 3.20774, 1, 0, 0.5,0.00178729)    );
  // itree = 19
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.474813,0.00323655) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.421012,-0.0273046) , 
10, -1.42792, 1, 0, 0.449101,-0.0130611) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.528769,0.00324878) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.521501,0.0373209) , 
0, 105.586, 1, 0, 0.528073,0.00863239) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.446091,-0.0275663) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.359149,-0.00140159) , 
7, 2.1824, 1, 0, 0.405857,-0.0182216) , 
5, 167.582, 1, 0, 0.5109,0.00485914) , 
9, -1.99908, 1, 0, 0.5,0.00169827)    );
  // itree = 20
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.58554,0.0174889) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.373572,-0.0219624) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.543469,0.00246701) , 
2, 38.0276, 1, 0, 0.49462,-0.00464344) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.488922,0.0287658) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.480484,0.0197728) , 
10, 0.285146, 1, 0, 0.485032,0.0313799) , 
2, 118.302, 1, 0, 0.493491,-0.000402957) , 
7, 0.860376, 1, 0, 0.5,0.00127851)    );
  // itree = 21
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.628216,0.0181423) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.583265,0.00622279) , 
9, 1.42783, 1, 0, 0.61608,0.0211618) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.570834,-0.0161951) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.461152,0.00670119) , 
4, 406.547, 1, 0, 0.515893,-0.00676184) , 
3, 232.427, 1, 0, 0.563083,0.00639085) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.485486,0.0257556) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.392484,-0.0118718) , 
4, 517.249, 1, 0, 0.414745,-0.00215412) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.31792,-0.0369611) , 
4, 873.02, 1, 0, 0.400017,-0.00718496) , 
3, 346.936, 1, 0, 0.5,0.00113895)    );
  // itree = 22
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.531679,0.00219285) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.43318,-0.0251742) , 
1, 39.1639, 1, 0, 0.463949,-0.02004) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.543116,0.0399104) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.406722,-0.0149046) , 
8, -2.10292, 1, 0, 0.472668,0.0174354) , 
0, 70.1835, 1, 0, 0.46697,-0.00705267) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.653022,0.0236901) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.413776,-0.0179168) , 
0, 81.0429, 1, 0, 0.584527,0.0173006) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.457632,-0.00881744) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.448626,0.0137247) , 
0, 92.306, 1, 0, 0.455892,-0.0055542) , 
8, 0.597261, 1, 0, 0.515728,0.00507696) , 
8, -0.856705, 1, 0, 0.5,0.00116429)    );
  // itree = 23
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.621179,0.0115538) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.407456,-0.0129055) , 
4, 339.137, 1, 0, 0.471696,-0.00547054) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.536832,0.0103336) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.494211,-0.00414627) , 
6, 104.517, 1, 0, 0.523292,0.00752896) , 
10, -0.856738, 1, 0, 0.506332,0.00325588) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.44672,-0.0120461) , 
7, 3.20774, 1, 0, 0.5,0.0013675)    );
  // itree = 24
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.605829,0.0289126) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.446451,-0.00979992) , 
10, 0.856532, 1, 0, 0.560032,0.024336) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.452963,-0.0352251) , 
6, 140.861, 1, 0, 0.534043,0.00819274) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.564015,-0.00010558) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.345496,-0.0222873) , 
3, 318.474, 1, 0, 0.48195,-0.00884058) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.490741,0.0322882) , 
2, 118.302, 1, 0, 0.483085,-0.00235959) , 
7, 1.79932, 1, 0, 0.5,0.00114314)    );
  // itree = 25
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.550401,-0.0022705) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.340373,-0.0300598) , 
3, 273.521, 1, 0, 0.431263,-0.0188607) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.557649,0.0124565) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.460393,-0.0116682) , 
8, 1.27216, 1, 0, 0.514,0.00232122) , 
8, -0.285604, 1, 0, 0.485547,-0.00496328) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.672657,0.0337335) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.535777,0.00862035) , 
7, 1.70495, 1, 0, 0.589051,0.0254998) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.514033,0.00429034) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.445665,-0.00742193) , 
5, 84.4611, 1, 0, 0.475039,-0.00260703) , 
9, 0.648997, 1, 0, 0.511514,0.00638508) , 
9, -0.285629, 1, 0, 0.5,0.00135303)    );
  // itree = 26
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.58554,0.0133843) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.515775,0.00679479) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.481431,-0.00363251) , 
6, 74.6872, 1, 0, 0.498459,0.00207299) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.421711,-0.0243347) , 
7, 3.42116, 1, 0, 0.493491,0.000106637) , 
7, 0.860376, 1, 0, 0.5,0.00132942)    );
  // itree = 27
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.533955,0.0077212) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.613079,0.0348512) , 
8, -0.286483, 1, 0, 0.579149,0.0307552) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.545012,0.00290559) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.479558,-0.0107798) , 
7, 1.79932, 1, 0, 0.502188,-0.00745747) , 
0, 35.6642, 1, 0, 0.514769,-0.0012106) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.553781,0.0257935) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.345783,-0.0121244) , 
3, 330.028, 1, 0, 0.441554,0.00962221) , 
0, 92.3025, 1, 0, 0.5,0.000974659)    );
  // itree = 28
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.478821,-0.00539112) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.446957,0.0194935) , 
0, 110.367, 1, 0, 0.474848,-0.00302457) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.72434,0.0298474) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.567568,0.00540994) , 
7, 2.15863, 1, 0, 0.653146,0.0252076) , 
8, -0.337467, 1, 0, 0.522077,0.0044537) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.521199,0.0017064) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.42091,-0.0300414) , 
10, 0.59716, 1, 0, 0.48539,-0.0111171) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.427543,-0.00619356) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.47399,0.021025) , 
8, 2.10307, 1, 0, 0.447505,0.0071962) , 
10, 1.42799, 1, 0, 0.47021,-0.00377901) , 
8, 0.285665, 1, 0, 0.5,0.000949527)    );
  // itree = 29
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.426763,-0.0152281) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.56155,0.00569688) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.437788,-0.00666034) , 
1, 56.3181, 1, 0, 0.49824,-0.000270252) , 
8, -1.42792, 1, 0, 0.485547,-0.00343726) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.607147,0.00123206) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.572031,0.0231631) , 
1, 58.3055, 1, 0, 0.589051,0.0168217) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.503054,0.00276458) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.420342,-0.00945357) , 
8, 0.285209, 1, 0, 0.475039,-0.00141091) , 
9, 0.648997, 1, 0, 0.511514,0.00442217) , 
9, -0.285629, 1, 0, 0.5,0.000937165)    );
  // itree = 30
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.452925,-0.00281994) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.260205,-0.0425656) , 
3, 328.737, 1, 0, 0.382484,-0.0151567) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.583805,0.00225386) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.399897,0.0226141) , 
4, 636.862, 1, 0, 0.556502,0.00616753) , 
2, 38.9109, 1, 0, 0.502847,-0.000407303) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.47453,0.00942802) , 
2, 128.021, 1, 0, 0.5,0.000805264)    );
  // itree = 31
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.599268,0.0183257) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.504096,0.000370747) , 
7, 1.33706, 1, 0, 0.518964,0.00410827) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.428505,-0.0167968) , 
6, 149.207, 1, 0, 0.509772,0.00172843) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.344764,-0.0139476) , 
1, 151.518, 1, 0, 0.5,0.000826532)    );
  // itree = 32
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.636736,0.0193531) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.62355,0.00256769) , 
6, 37.6438, 1, 0, 0.626623,0.00916334) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.558736,-0.0130309) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.511118,-0.043445) , 
9, 0.284468, 1, 0, 0.537524,-0.0345066) , 
4, 362.055, 1, 0, 0.601255,-0.00327031) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.501479,0.0269681) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.425025,-0.000602961) , 
1, 74.0292, 1, 0, 0.463268,0.017297) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.444266,0.00314898) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.335307,-0.0117015) , 
7, 2.17371, 1, 0, 0.388791,-0.0042794) , 
3, 368.569, 1, 0, 0.417335,0.0039899) , 
4, 410.486, 1, 0, 0.5,0.000726703)    );
  // itree = 33
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.47451,-0.0299156) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.531469,0.00478809) , 
5, 27.0104, 1, 0, 0.527495,0.00307341) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.343108,-0.0355496) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.463083,0.00539065) , 
2, 56.7234, 1, 0, 0.395296,-0.0168272) , 
5, 147.605, 1, 0, 0.502847,-0.000636924) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.47453,0.0103192) , 
2, 128.021, 1, 0, 0.5,0.000707142)    );
  // itree = 34
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.49185,0.00486657) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.4128,-0.0145044) , 
10, 0.285907, 1, 0, 0.474746,0.00106375) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.437072,-0.0274887) , 
8, 1.9965, 1, 0, 0.46912,-0.00402345) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.483505,0.0145833) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.50356,-0.00882962) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.525955,0.00463445) , 
10, -0.128822, 1, 0, 0.519978,0.0013843) , 
10, -1.99827, 1, 0, 0.516171,0.0031632) , 
9, -0.856779, 1, 0, 0.5,0.000693194)    );
  // itree = 35
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.574714,0.0137071) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.485886,-0.00571488) , 
7, 2.17158, 1, 0, 0.519625,0.00228867) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.447802,0.0172821) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.489776,-0.0196637) , 
10, -1.47989, 1, 0, 0.477841,-0.0108597) , 
6, 104.517, 1, 0, 0.507474,-0.0015348) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.456053,-0.0176374) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.405837,0.00904605) , 
5, 66.3339, 1, 0, 0.431884,-0.00647898) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.520469,0.0227938) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.501816,0.00349911) , 
7, 2.86666, 1, 0, 0.510805,0.0164763) , 
7, 2.26879, 1, 0, 0.47741,0.00676277) , 
10, 1.42799, 1, 0, 0.5,0.000528095)    );
  // itree = 36
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.506659,0.0049462) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.445353,-0.00609027) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.393476,-0.018275) , 
10, -1.9991, 1, 0, 0.417429,-0.0140187) , 
6, 58.5703, 1, 0, 0.449101,-0.00690133) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.541958,0.00626882) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.392761,-0.020239) , 
1, 115.894, 1, 0, 0.523665,0.00446337) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.427495,-0.0223779) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.476228,0.00499292) , 
8, -0.2859, 1, 0, 0.453738,-0.0088667) , 
9, 2.20668, 1, 0, 0.5109,0.00203004) , 
9, -1.99908, 1, 0, 0.5,0.000454678)    );
  // itree = 37
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.671337,0.0151423) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.614496,-0.000226294) , 
4, 262.992, 1, 0, 0.626623,0.0042858) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.558736,-0.00942506) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.511118,-0.0301097) , 
9, 0.284468, 1, 0, 0.537524,-0.0243541) , 
4, 362.055, 1, 0, 0.601255,-0.00386851) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.381711,-0.00106449) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.529965,0.0173964) , 
2, 52.1899, 1, 0, 0.463268,0.0124473) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.424981,-0.00820102) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.351108,0.00787645) , 
4, 653.615, 1, 0, 0.388791,-0.00106852) , 
3, 368.569, 1, 0, 0.417335,0.00411152) , 
4, 410.486, 1, 0, 0.5,0.000524792)    );
  // itree = 38
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.505319,0.00346188) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.473285,-0.00929112) , 
6, 66.5324, 1, 0, 0.486254,-0.00484174) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.551753,0.0106127) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.497268,-0.00146444) , 
5, 68.184, 1, 0, 0.513298,0.00289152) , 
9, -0.28576, 1, 0, 0.501159,-0.000579512) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.487864,0.00845771) , 
10, 2.57035, 1, 0, 0.5,0.000400642)    );
  // itree = 39
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.564503,-5.19352e-05) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.589544,0.0248692) , 
5, 60.5583, 1, 0, 0.579149,0.0185083) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.50383,-0.00564286) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.48476,0.00923008) , 
2, 128.021, 1, 0, 0.502188,-0.0053947) , 
0, 35.6642, 1, 0, 0.514769,-0.00148712) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.400562,-0.0141788) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.535875,0.0266239) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.38578,0.00439354) , 
1, 58.7237, 1, 0, 0.464346,0.0205213) , 
7, 2.16648, 1, 0, 0.441554,0.00747432) , 
0, 92.3025, 1, 0, 0.5,0.00032063)    );
  // itree = 40
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.500111,0.00164522) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.474416,-0.0131137) , 
8, 1.42805, 1, 0, 0.497078,-0.00017387) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.603266,0.0205766) , 
10, -0.026154, 1, 0, 0.510217,0.00314169) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.570291,0.00110537) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.388259,-0.0333472) , 
5, 124.947, 1, 0, 0.500534,-0.0127756) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.474837,-0.00273836) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.49024,0.0228672) , 
0, 92.3042, 1, 0, 0.477864,0.00285974) , 
10, 1.32415, 1, 0, 0.486811,-0.00331073) , 
10, 0.285625, 1, 0, 0.5,0.000325169)    );
  // itree = 41
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.430864,-0.0243288) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.493925,0.000968291) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.542076,0.0193108) , 
0, 70.1995, 1, 0, 0.51324,0.0109675) , 
7, 2.17054, 1, 0, 0.480394,-0.00502654) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.559847,0.013238) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.472689,-0.0117991) , 
6, 129.095, 1, 0, 0.537239,0.00866097) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.470817,-0.00838402) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.489453,0.0185033) , 
2, 118.302, 1, 0, 0.473705,-0.00482145) , 
7, 2.26879, 1, 0, 0.505908,0.00201241) , 
8, -1.42789, 1, 0, 0.5,0.000382432)    );
  // itree = 42
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.585521,0.0152459) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.522829,-0.00110455) , 
1, 20.0276, 1, 0, 0.53014,0.00112598) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.367029,-0.023464) , 
1, 109.273, 1, 0, 0.518578,-0.000707546) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.43065,-0.00221421) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.362233,0.0146332) , 
7, 2.1824, 1, 0, 0.392927,0.00718573) , 
5, 167.582, 1, 0, 0.5,0.000459525)    );
  // itree = 43
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.58554,0.00808494) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.533398,0.0261093) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.505495,0.000817349) , 
6, 20.491, 1, 0, 0.508951,0.00508888) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.468756,0.0116771) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.478961,-0.00860605) , 
10, -1.99918, 1, 0, 0.477252,-0.00613856) , 
6, 74.6872, 1, 0, 0.493491,-0.000386988) , 
7, 0.860376, 1, 0, 0.5,0.000363436)    );
  // itree = 44
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.428192,-0.0170539) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.50265,0.0059837) , 
7, 2.10091, 1, 0, 0.45916,-0.00869179) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.564187,0.0110942) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.444863,-0.0075805) , 
8, 1.06428, 1, 0, 0.522693,0.00583499) , 
8, -1.42806, 1, 0, 0.508859,0.00267171) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.521603,0.0132978) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.470242,-0.0154759) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.47218,0.00410646) , 
8, 0.856882, 1, 0, 0.470925,-0.0102318) , 
10, -1.9989, 1, 0, 0.481053,-0.00477008) , 
7, 2.73827, 1, 0, 0.5,0.000300816)    );
  // itree = 45
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.463241,-0.00362808) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.616853,0.0107497) , 
8, -0.649004, 1, 0, 0.52257,0.00251884) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.42435,-0.0206114) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.479588,-0.000841872) , 
9, -1.99855, 1, 0, 0.470667,-0.00467766) , 
8, 0.285691, 1, 0, 0.501159,-0.000449813) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.487864,0.0073925) , 
10, 2.57035, 1, 0, 0.5,0.000399859)    );
  // itree = 46
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.57325,0.00939494) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.49094,-0.00390564) , 
0, 39.564, 1, 0, 0.509572,-0.00099575) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.448497,0.0254144) , 
0, 135.204, 1, 0, 0.505202,0.00119702) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.45036,-0.00598805) , 
9, 2.57012, 1, 0, 0.5,0.000406849)    );
  // itree = 47
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.478063,-0.0123977) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.542343,0.0069419) , 
5, 40.4097, 1, 0, 0.532571,0.00503348) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.416689,-0.020429) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.409361,0.000130281) , 
1, 117.173, 1, 0, 0.413087,-0.0115992) , 
5, 147.605, 1, 0, 0.508859,0.00173259) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.537403,0.00509451) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.469157,-0.0149656) , 
5, 76.5909, 1, 0, 0.500353,-0.0067545) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.382405,0.0165244) , 
5, 167.859, 1, 0, 0.481053,-0.00275552) , 
7, 2.73827, 1, 0, 0.5,0.000302713)    );
  // itree = 48
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.620605,0.00976823) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.605702,-0.00198872) , 
6, 47.3805, 1, 0, 0.61044,0.00250306) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.554281,-0.0192192) , 
3, 270.612, 1, 0, 0.601255,-0.00206461) , 
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.492641,0.0197479) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.41147,-0.000451892) , 
4, 454.514, 1, 0, 0.428281,0.00477572) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.315117,-0.0235997) , 
4, 894.786, 1, 0, 0.417335,0.00223518) , 
4, 410.486, 1, 0, 0.5,0.000302585)    );
  // itree = 49
  fBoostWeights.push_back(1);
  fForest.push_back( 
NN(
NN(
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.560979,0.0156782) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.540992,-0.000909104) , 
6, 29.1029, 1, 0, 0.543443,0.0015505) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.392433,-0.0202833) , 
4, 579.985, 1, 0, 0.527272,-0.000969475) , 
NN(
NN(
0, 
0, 
-1, 0, 1, -99, 0.365832,0.0223236) , 
NN(
0, 
0, 
-1, 0, 1, -99, 0.324039,-0.00930043) , 
3, 641.246, 1, 0, 0.345789,0.00744096) , 
4, 676.848, 1, 0, 0.5,0.000294389)    );
   return;
};
 
// Clean up
inline void ReadBDT::Clear() 
{
   for (unsigned int itree=0; itree<fForest.size(); itree++) { 
      delete fForest[itree]; 
   }
}
   inline double ReadBDT::GetMvaValue( const std::vector<double>& inputValues ) const
   {
      // classifier response value
      double retval = 0;

      // classifier response, sanity check first
      if (!IsStatusClean()) {
         std::cout << "Problem in class \"" << fClassName << "\": cannot return classifier response"
                   << " because status is dirty" << std::endl;
         retval = 0;
      }
      else {
         if (IsNormalised()) {
            // normalise variables
            std::vector<double> iV;
            iV.reserve(inputValues.size());
            int ivar = 0;
            for (std::vector<double>::const_iterator varIt = inputValues.begin();
                 varIt != inputValues.end(); varIt++, ivar++) {
               iV.push_back(NormVariable( *varIt, fVmin[ivar], fVmax[ivar] ));
            }
            retval = GetMvaValue__( iV );
         }
         else {
            retval = GetMvaValue__( inputValues );
         }
      }

      return retval;
   }
